<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mr. Handyman Best Practices</title>
    <style>
@import url('https://fonts.googleapis.com/css2?family=Nunito+Sans:wght@400;600;700&display=swap');

:root {
  color-scheme: light dark;
  font-family: 'Nunito Sans', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  line-height: 1.6;
  --clarity-navy: #4b1e00;
  --clarity-blue: #e26b0a;
  --clarity-sky: #ff9f4d;
  --clarity-orange: #ff7a29;
  --surface: #ffffff;
  --surface-alt: #fff4ea;
  --surface-soft: #fff9f2;
  --border: #f1c8a6;
  --border-strong: #c46a21;
  --text: #2d1505;
  --text-muted: #7c5233;
  --success: #0d8c6f;
  --warning: #f4871e;
  --danger: #c2452d;
}

@media (prefers-color-scheme: dark) {
  :root {
    --surface: #1f1209;
    --surface-alt: #25170d;
    --surface-soft: #2f1f13;
    --border: #4a2a16;
    --border-strong: #e08847;
    --text: #fceee2;
    --text-muted: #d9c0aa;
    --clarity-blue: #ff8f45;
    --clarity-sky: #ffb874;
    --clarity-orange: #ff9858;
  }
}

body {
  margin: 0;
  padding: 0;
  background: radial-gradient(circle at top left, rgba(255, 170, 102, 0.22), transparent 55%),
    radial-gradient(circle at top right, rgba(146, 57, 0, 0.18), transparent 60%), var(--surface-alt);
  color: var(--text);
}

body.no-scroll {
  overflow: hidden;
}

.app-shell {
  display: grid;
  gap: 2rem;
  align-items: flex-start;
  max-width: 1240px;
  margin: 0 auto;
  padding: 2.5rem 1.5rem 4rem;
}

@media (min-width: 1080px) {
  .app-shell {
    grid-template-columns: minmax(0, 1.75fr) minmax(320px, 1fr);
  }
}

@media (max-width: 1079px) {
  .app-shell {
    grid-template-columns: 1fr;
  }
}

main {
  margin: 0;
  padding: 0;
}

header h1 {
  margin-bottom: 0.75rem;
  font-size: clamp(1.9rem, 2.4vw + 1.15rem, 2.7rem);
  color: var(--clarity-navy);
}

header p {
  margin-top: 0;
  max-width: 70ch;
  color: var(--text-muted);
}

.controls {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
  margin-bottom: 1.5rem;
}

.share-status {
  flex: 1 1 100%;
  margin: 0;
  padding: 0.85rem 1rem;
  border-radius: 14px;
  border: 1px solid var(--border);
  background: var(--surface-soft);
  color: var(--clarity-navy);
  font-size: 0.95rem;
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
  box-shadow: 0 12px 28px -26px rgba(196, 91, 19, 0.4);
}

.share-status[hidden] {
  display: none;
}

.share-status[data-tone='success'] {
  border-color: rgba(13, 140, 111, 0.35);
  background: linear-gradient(135deg, rgba(13, 140, 111, 0.12), rgba(13, 140, 111, 0.08));
  color: var(--success);
}

.share-status[data-tone='warning'] {
  border-color: rgba(244, 135, 30, 0.35);
  background: linear-gradient(135deg, rgba(244, 135, 30, 0.16), rgba(244, 135, 30, 0.08));
  color: var(--warning);
}

.share-status[data-tone='error'] {
  border-color: rgba(194, 69, 45, 0.35);
  background: linear-gradient(135deg, rgba(194, 69, 45, 0.16), rgba(194, 69, 45, 0.08));
  color: var(--danger);
}

.share-status[data-tone='info'] {
  border-color: rgba(226, 107, 10, 0.28);
  background: linear-gradient(135deg, rgba(226, 107, 10, 0.16), rgba(255, 159, 77, 0.12));
  color: var(--clarity-navy);
}

.share-status__message {
  font-weight: 600;
}

.share-status__link-block {
  display: flex;
  flex-wrap: wrap;
  gap: 0.4rem;
  align-items: baseline;
  color: var(--clarity-navy);
}

.share-status__link-block span {
  font-weight: 500;
}

.share-status__link {
  word-break: break-all;
  color: inherit;
  text-decoration: underline;
}

.live-preview {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 18px;
  padding: 1.75rem;
  box-shadow: 0 24px 48px -32px rgba(196, 91, 19, 0.35);
  position: sticky;
  top: 2.5rem;
  max-height: calc(100vh - 5rem);
  overflow: auto;
}

@media (max-width: 1079px) {
  .live-preview {
    position: static;
    max-height: none;
    order: -1;
  }
}

.live-preview__header {
  margin-bottom: 1.5rem;
}

.live-preview__header h2 {
  margin: 0 0 0.5rem;
  font-size: 1.4rem;
  color: var(--clarity-navy);
}

.live-preview__header p {
  margin: 0;
  color: var(--text-muted);
}

.live-preview__body {
  display: grid;
  gap: 1.25rem;
}

.live-preview__summary {
  background: linear-gradient(135deg, rgba(226, 107, 10, 0.2), rgba(255, 159, 77, 0.18));
  border-radius: 14px;
  padding: 1.25rem;
  color: var(--clarity-navy);
  border: 1px solid rgba(226, 107, 10, 0.22);
  display: grid;
  gap: 0.4rem;
}

.live-preview__summary strong {
  font-size: 1.1rem;
}

.live-preview__summary span {
  color: var(--text-muted);
}

.live-preview__section {
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 1.2rem;
  background: var(--surface-soft);
  display: grid;
  gap: 0.75rem;
}

.live-preview__section-status,
.preview__section-status {
  margin: 0;
  padding: 0.65rem 0.85rem;
  border-radius: 12px;
  font-weight: 600;
  border: 1px solid rgba(226, 107, 10, 0.28);
  background: rgba(255, 159, 77, 0.16);
  color: var(--clarity-blue);
}

.live-preview__section-status[data-tone='success'],
.preview__section-status[data-tone='success'] {
  border-color: rgba(13, 140, 111, 0.2);
  background: rgba(13, 140, 111, 0.12);
  color: var(--success);
}

.live-preview__section-status[data-tone='warning'],
.preview__section-status[data-tone='warning'] {
  border-color: rgba(244, 135, 30, 0.24);
  background: rgba(244, 135, 30, 0.12);
  color: var(--warning);
}

.live-preview__section-status[data-tone='danger'],
.preview__section-status[data-tone='danger'] {
  border-color: rgba(194, 69, 45, 0.24);
  background: rgba(194, 69, 45, 0.1);
  color: var(--danger);
}

.live-preview__section-suggestion,
.preview__section-suggestion {
  margin: 0;
  color: var(--text-muted);
  font-style: italic;
  padding-left: 0.25rem;
}

.live-preview__section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 0.75rem;
}

.live-preview__section-title {
  margin: 0;
  font-size: 1.05rem;
  color: var(--clarity-navy);
}

.live-preview__section-progress {
  font-weight: 700;
  color: var(--clarity-blue);
}

.live-preview__items {
  display: grid;
  gap: 0.5rem;
  margin: 0;
  padding: 0;
  list-style: none;
}

.live-preview__item {
  display: flex;
  justify-content: space-between;
  gap: 1rem;
  font-size: 0.92rem;
}

.live-preview__item-label {
  color: var(--text-muted);
}

.live-preview__item-status {
  font-weight: 700;
  color: var(--clarity-blue);
}

.live-preview__item-status[data-state='pending'] {
  color: var(--warning);
}

.live-preview__item-status[data-state='complete'] {
  color: var(--success);
}

.link-button,
button {
  border: none;
  border-radius: 999px;
  padding: 0.6rem 1.3rem;
  background: linear-gradient(135deg, var(--clarity-blue), var(--clarity-sky));
  color: white;
  font-weight: 700;
  letter-spacing: 0.01em;
  cursor: pointer;
  transition: transform 0.15s ease, box-shadow 0.2s ease;
  box-shadow: 0 8px 18px -10px rgba(226, 107, 10, 0.45);
}

.link-button:hover,
.link-button:focus-visible,
button:hover,
button:focus-visible {
  transform: translateY(-1px);
  box-shadow: 0 12px 22px -12px rgba(226, 107, 10, 0.58);
}

.link-button:focus-visible,
button:focus-visible {
  outline: 3px solid rgba(255, 159, 77, 0.45);
  outline-offset: 2px;
}

.link-button.secondary,
button.secondary {
  background: transparent;
  border: 1px solid var(--border);
  color: var(--clarity-blue);
  box-shadow: none;
}

.link-button.secondary:hover,
.link-button.secondary:focus-visible,
button.secondary:hover,
button.secondary:focus-visible {
  background: var(--surface-soft);
  border-color: var(--clarity-blue);
  color: var(--clarity-navy);
}

.link-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  text-decoration: none;
}

.section__actions .link-button {
  font-weight: 700;
}

.progress {
  margin: 2rem 0 1rem;
  padding: 1.4rem;
  border-radius: 16px;
  border: 1px solid rgba(196, 91, 19, 0.3);
  background: linear-gradient(120deg, rgba(226, 107, 10, 0.92), rgba(75, 30, 0, 0.94));
  color: white;
}

.progress h2 {
  margin-top: 0;
  color: inherit;
}

.progress-bar {
  position: relative;
  width: 100%;
  height: 16px;
  border-radius: 999px;
  background: rgba(255, 255, 255, 0.18);
  overflow: hidden;
}

.progress-bar__fill {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: 0;
  background: linear-gradient(90deg, var(--clarity-orange), var(--clarity-sky));
  transition: width 0.3s ease;
}

.progress__summary {
  margin: 0.75rem 0 0;
  font-weight: 700;
}

.section {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 1.5rem;
  margin-top: 1.75rem;
  box-shadow: 0 20px 45px -28px rgba(196, 91, 19, 0.32);
  position: relative;
  overflow: hidden;
}

.section::before {
  content: '';
  position: absolute;
  inset: 0;
  opacity: 0.22;
  background: linear-gradient(120deg, transparent 0 35%, rgba(255, 106, 19, 0.18) 50%, transparent 75%);
  pointer-events: none;
}

.section__header {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  align-items: center;
  justify-content: space-between;
}

.section__title {
  margin: 0;
  font-size: 1.35rem;
  color: var(--clarity-navy);
}

.section__intro {
  margin: 0.5rem 0 1.5rem;
  color: var(--text-muted);
}

.section__actions {
  display: flex;
  gap: 0.75rem;
}

.task {
  display: grid;
  gap: 0.4rem;
  padding: 1rem;
  border: 1px solid var(--border);
  border-radius: 12px;
  background: var(--surface-soft);
  margin-bottom: 1rem;
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
}

.task.completed {
  border-color: rgba(13, 140, 111, 0.55);
  box-shadow: 0 8px 20px -12px rgba(13, 140, 111, 0.45);
}

.task label {
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 0.75rem;
  align-items: start;
  font-weight: 600;
}

.task input[type='checkbox'] {
  width: 1.2rem;
  height: 1.2rem;
  accent-color: var(--clarity-orange);
}

.task__details summary {
  font-weight: 600;
  color: var(--clarity-blue);
  cursor: pointer;
}

.task__description {
  margin-top: 0.6rem;
  color: var(--text-muted);
  font-size: 0.95rem;
}

.note-line {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-top: 0.75rem;
  font-size: 0.9rem;
  color: var(--text-muted);
}

.fill-line {
  flex: 1;
  display: block;
  min-width: 6rem;
  border-bottom: 1px dashed var(--border);
  height: 0.85em;
}

.options {
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 1rem;
  margin-bottom: 1.2rem;
  background: var(--surface-soft);
}

.options legend {
  font-weight: 700;
  margin-bottom: 0.8rem;
  color: var(--clarity-navy);
}

.options__description {
  margin: 0 0 0.8rem;
  color: var(--text-muted);
  font-size: 0.95rem;
}

.option {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  margin-bottom: 0.5rem;
  font-weight: 500;
  cursor: pointer;
}

.option__label {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
}

.option__note {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.85rem;
  font-weight: 400;
  color: var(--text-muted);
}

.option__note .fill-line {
  min-width: 5rem;
}

.option:last-child {
  margin-bottom: 0;
}

.option input {
  accent-color: var(--clarity-orange);
}

.section__insights {
  margin-top: 1rem;
  padding: 0.85rem 1rem;
  border-radius: 12px;
  border: 1px solid transparent;
  background: none;
  color: var(--text-muted);
  font-size: 0.95rem;
}

.section__insights.is-visible {
  background: rgba(255, 159, 77, 0.16);
  border-color: rgba(226, 107, 10, 0.3);
  color: var(--clarity-blue);
}

.section__insights.is-success {
  background: rgba(13, 140, 111, 0.16);
  border-color: rgba(13, 140, 111, 0.4);
  color: var(--success);
}

.section__insights[data-tone='warning'] {
  background: rgba(244, 135, 30, 0.12);
  border-color: rgba(244, 135, 30, 0.35);
  color: var(--warning);
}

.section__insights strong {
  display: block;
  margin-bottom: 0.35rem;
}

.section__insights-text {
  display: block;
}

.preview {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.preview[aria-hidden='false'] {
  pointer-events: auto;
  opacity: 1;
}

.preview__backdrop {
  position: absolute;
  inset: 0;
  background: rgba(15, 28, 46, 0.56);
}

.preview__dialog {
  position: relative;
  width: min(720px, 92%);
  max-height: 90vh;
  overflow-y: auto;
  background: var(--surface);
  border-radius: 18px;
  box-shadow: 0 24px 60px -24px rgba(15, 23, 42, 0.45);
  border: 1px solid var(--border);
  display: flex;
  flex-direction: column;
}

.preview__header {
  padding: 1.2rem 1.6rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid var(--border);
}

.preview__header h2 {
  margin: 0;
  font-size: 1.35rem;
  color: var(--clarity-navy);
}

.preview__dialog:focus-visible {
  outline: 3px solid rgba(255, 159, 77, 0.45);
  outline-offset: 2px;
}

.preview__close {
  border: none;
  background: transparent;
  color: var(--text-muted);
  font-size: 1.7rem;
  line-height: 1;
  width: 2.25rem;
  height: 2.25rem;
  border-radius: 999px;
  display: grid;
  place-items: center;
  cursor: pointer;
}

.preview__close:hover,
.preview__close:focus-visible {
  background: var(--surface-alt);
  color: var(--clarity-blue);
}

.preview__description {
  margin: 0;
  padding: 0 1.6rem 0.5rem;
  color: var(--text-muted);
  font-size: 0.95rem;
}

.preview__body {
  padding: 1.25rem 1.6rem 1.8rem;
  display: grid;
  gap: 1.5rem;
}

.preview__summary {
  padding: 1rem 1.1rem;
  border-radius: 14px;
  background: var(--surface-soft);
  border: 1px solid var(--border);
  font-weight: 600;
  color: var(--text-muted);
}

.preview__section {
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 1.2rem 1.4rem;
  background: var(--surface-soft);
  display: grid;
  gap: 0.85rem;
}

.preview__section-header {
  display: flex;
  align-items: baseline;
  justify-content: space-between;
  gap: 0.75rem;
  margin: 0;
}

.preview__section-title {
  margin: 0;
  font-size: 1.1rem;
  color: var(--clarity-navy);
}

.preview__section-progress {
  font-size: 0.9rem;
  color: var(--text-muted);
  font-weight: 600;
}

.preview__items {
  display: grid;
  gap: 0.75rem;
}

.preview__item {
  display: flex;
  justify-content: space-between;
  gap: 0.75rem;
  align-items: flex-start;
}

.preview__item-label {
  font-weight: 600;
  color: var(--clarity-navy);
}

.preview__item-status {
  font-size: 0.92rem;
  color: var(--text-muted);
  text-align: right;
}

.preview__item-status[data-state='pending'] {
  color: var(--warning);
}

.preview__item-status[data-state='complete'] {
  color: var(--success);
}

.demo {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1100;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.demo[aria-hidden='false'] {
  pointer-events: auto;
  opacity: 1;
}

.demo__backdrop {
  position: absolute;
  inset: 0;
  background: rgba(75, 30, 0, 0.6);
}

.demo__dialog {
  position: relative;
  width: min(480px, 92%);
  max-height: 80vh;
  overflow-y: auto;
  background: var(--surface);
  border-radius: 18px;
  box-shadow: 0 26px 64px -24px rgba(120, 46, 5, 0.55);
  border: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  gap: 1rem;
  padding: 1.35rem 1.5rem 1.6rem;
}

.demo__dialog:focus-visible {
  outline: 3px solid rgba(255, 159, 77, 0.45);
  outline-offset: 3px;
}

.demo__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 1rem;
}

.demo__header h2 {
  margin: 0;
  font-size: 1.35rem;
  color: var(--clarity-navy);
}

.demo__close {
  border: none;
  background: transparent;
  color: var(--text-muted);
  font-size: 1.7rem;
  line-height: 1;
  width: 2.25rem;
  height: 2.25rem;
  border-radius: 999px;
  display: grid;
  place-items: center;
  cursor: pointer;
}

.demo__close:hover,
.demo__close:focus-visible {
  background: var(--surface-alt);
  color: var(--clarity-blue);
}

.demo__description {
  margin: 0;
  color: var(--text-muted);
  font-size: 0.96rem;
}

.demo__body {
  display: grid;
  gap: 0.85rem;
}

.demo__step-indicator {
  margin: 0;
  color: var(--clarity-blue);
  font-weight: 600;
  font-size: 0.9rem;
  letter-spacing: 0.02em;
  text-transform: uppercase;
}

.demo__step-title {
  margin: 0;
  color: var(--clarity-navy);
  font-size: 1.1rem;
}

.demo__step-text {
  margin: 0;
  color: var(--text-muted);
  font-size: 0.98rem;
}

.demo__controls {
  display: flex;
  gap: 0.75rem;
  justify-content: flex-end;
}

.demo__controls button {
  min-width: 120px;
}

.demo-highlight {
  position: relative;
  isolation: isolate;
  box-shadow: 0 0 0 4px rgba(255, 159, 77, 0.55), 0 18px 48px -24px rgba(120, 46, 5, 0.5);
  border-radius: 16px;
  transition: box-shadow 0.2s ease;
}

.demo-highlight::after {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: inherit;
  background: rgba(255, 159, 77, 0.15);
  pointer-events: none;
  z-index: -1;
}

.demo-highlight button,
.demo-highlight a,
.demo-highlight input,
.demo-highlight select,
.demo-highlight textarea {
  position: relative;
  z-index: 2;
}

@media (max-width: 720px) {
  main {
    padding: 1.75rem 1.1rem 3rem;
  }

  .section__header {
    align-items: flex-start;
  }

  .section__actions {
    width: 100%;
    justify-content: flex-start;
  }

  button {
    width: 100%;
    justify-content: center;
  }
}

@media (max-width: 420px) {
  header h1 {
    font-size: 1.75rem;
  }

  .controls {
    flex-direction: column;
  }
}

</style>
  </head>
  <body>
    <div class="app-shell">
      <main>
        <header>
          <h1>Mr. Handyman Best Practices Checklist</h1>
          <p>
            Use this interactive tool to confirm Mr. Handyman best practices
            across call flow, time frames, and required configuration. Progress
            is saved locally so you can revisit and continue verifying
            configurations as needed.
          </p>
        </header>

        <section class="progress" aria-live="polite">
          <h2>Overall Progress</h2>
          <div class="progress-bar" role="progressbar" aria-valuemin="0" aria-valuemax="100">
            <div class="progress-bar__fill"></div>
          </div>
          <p class="progress__summary"></p>
        </section>

        <section class="controls">
          <button id="btn-clear" type="button" class="secondary">
            Clear Saved Progress
          </button>
          <button id="btn-share" type="button" class="secondary">
            Share Progress Link
          </button>
          <button id="btn-demo" type="button" class="secondary">
            Mr.Handyman Best Practies Checklist
          </button>
          <button id="btn-preview" type="button">
            Environment Preview
          </button>
          <p
            id="share-status"
            class="share-status"
            role="status"
            aria-live="polite"
            hidden
          ></p>
        </section>

        <div id="checklist" class="checklist" aria-live="polite"></div>
      </main>

      <aside
        id="live-preview"
        class="live-preview"
        aria-labelledby="live-preview-title"
      >
        <div class="live-preview__header">
          <h2 id="live-preview-title">Live Environment Preview</h2>
          <p>
            Review your configuration snapshot as you work. The panel updates in
            real time and mirrors the Environment Preview dialog for quick
            cross-checking.
          </p>
        </div>
        <div class="live-preview__body" aria-live="polite"></div>
      </aside>
    </div>

    <div
      id="preview-overlay"
      class="preview"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
      aria-labelledby="preview-title"
      aria-describedby="preview-description"
      hidden
    >
      <div class="preview__backdrop" data-preview-close></div>
      <div class="preview__dialog" role="document" tabindex="-1">
        <header class="preview__header">
          <h2 id="preview-title">Environment Preview</h2>
          <button
            type="button"
            class="preview__close"
            aria-label="Close environment preview"
            data-preview-close
          >
            ×
          </button>
        </header>
        <p id="preview-description" class="preview__description">
          Snapshot of the current checklist configuration. Use the Environment Preview
          to review completed and pending items without making changes.
        </p>
        <div class="preview__body"></div>
      </div>
    </div>

    <div
      id="demo-overlay"
      class="demo"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
      aria-labelledby="demo-title"
      hidden
    >
      <div class="demo__backdrop" data-demo-close></div>
      <div class="demo__dialog" role="document" tabindex="-1">
        <header class="demo__header">
          <h2 id="demo-title">Mr.Handyman Best Practies Checklist</h2>
          <button
            type="button"
            class="demo__close"
            aria-label="Close Mr.Handyman Best Practies Checklist"
            data-demo-close
          >
            ×
          </button>
        </header>
        <p class="demo__description">
          Follow the guided walkthrough to highlight the key areas of the Mr.Handyman Best Practies Checklist during a live presentation.
          Your saved progress will be restored when you end the demo.
        </p>
        <div class="demo__body">
          <p class="demo__step-indicator"></p>
          <h3 class="demo__step-title"></h3>
          <p class="demo__step-text"></p>
          <div class="demo__controls">
            <button type="button" class="secondary" data-demo-prev>
              Previous
            </button>
            <button type="button" data-demo-next>
              Next
            </button>
          </div>
        </div>
      </div>
    </div>

    <template id="task-template">
      <div class="task" data-task-id="">
        <label>
          <input type="checkbox" />
          <span class="task__text"></span>
        </label>
        <details class="task__details">
          <summary>Details &amp; Notes</summary>
          <div class="task__description"></div>
        </details>
      </div>
    </template>

    <template id="option-template">
      <fieldset class="options" data-group-id="">
        <legend></legend>
      </fieldset>
    </template>

    <template id="radio-template">
      <label class="option">
        <input type="radio" name="" value="" />
        <span class="option__label"></span>
      </label>
    </template>

    <template id="checkbox-template">
      <label class="option">
        <input type="checkbox" value="" />
        <span class="option__label"></span>
      </label>
    </template>

    <template id="section-template">
      <section class="section">
        <header class="section__header">
          <h2 class="section__title"></h2>
          <div class="section__actions">
            <a
              class="btn-suggest link-button"
              href="https://chat.openai.com/"
              target="_blank"
              rel="noopener noreferrer"
            >
              AI Suggestions
            </a>
          </div>
        </header>
        <p class="section__intro"></p>
        <div class="section__content"></div>
        <div class="section__insights" aria-live="polite"></div>
      </section>
    </template>

    <script>
const STORAGE_KEY = 'mr-handyman-checklist-v1';
const SHARE_PARAM = 'state';

const checklistData = [
  {
    id: 'best-practices',
    title: 'Mr. Handyman Best Practices',
    intro:
      'Confirm the franchise-specific call flow foundations. Mr. Handyman does not participate in the Own The Number (OTN) program, so rely on live-answer processes instead.',
    suggestions: () =>
      'Document who provides live answer coverage and keep the technician hotline information handy for quick updates.',
  },
  {
    id: 'time-frames',
    title: 'Time Frames & Answering Rules',
    intro:
      'Document operating hours, holidays, and fallback destinations to guarantee consistent coverage across daytime, after-hours, and holiday routing.',
    tasks: [
      {
        id: 'daytime-frame',
        label: 'Create and test the Daytime Time Frame',
        descriptionHtml:
          'Confirm the days/hours the office is open and configure the matching Daytime Time Frame. Test by placing a call during an in-window time.<div class="note-line"><strong>Confirmed hours:</strong> <span class="fill-line" aria-hidden="true"></span></div>',
      },
      {
        id: 'holiday-frame',
        label: 'Build a Holiday Time Frame for the current year',
        description:
          'Ask the franchise which holidays they will close for this year. Create those entries and document any partial-day coverage expectations.',
      },
      {
        id: 'holiday-routing',
        label: 'Verify holiday routing destination',
        description:
          'Confirm the customer’s choice for holiday handling (voicemail, mobile redirect, or answering service) and test at least one scenario.',
      },
    ],
    options: [
      {
        id: 'after-hours-destination',
        type: 'radio',
        legend: 'After-hours routing preference (Default/AfterHours Rule)',
        description:
          'Capture the selected after-hours handling so you can audit it later.',
        choices: [
          {
            value: 'voicemail',
            label: 'Send to voicemail on Clarity phone',
            note: 'Voicemail box:',
          },
          {
            value: 'cell-then-voicemail',
            label: 'Ring cell phone(s), then Clarity voicemail',
          },
          {
            value: 'answering-service',
            label: 'Forward to answering service',
            note: 'Forward to number:',
          },
        ],
      },
    ],
    suggestions: (state) => {
      if (!state.byId('holiday-frame')) {
        return 'List upcoming holidays with the owner and confirm the calendar is populated before launch.';
      }
      if (!state.optionSelected('after-hours-destination')) {
        return 'Capture the after-hours preference to make sure the answering rules align with the customer’s expectations.';
      }
      return 'Run a simulated after-hours call to be certain that the selected option matches production behavior.';
    },
    crossCheck: (state) => {
      const pending = [];
      if (!state.byId('daytime-frame')) pending.push('Daytime Time Frame missing.');
      if (!state.byId('holiday-frame')) pending.push('Holiday Time Frame not configured.');
      if (!state.optionSelected('after-hours-destination'))
        pending.push('After-hours destination not captured.');
      if (!state.byId('holiday-routing'))
        pending.push('Holiday routing destination still needs testing.');
      if (!pending.length) {
        return {
          tone: 'success',
          message:
            'Time frames and answering rules are fully documented. Remember to revisit annually to refresh holiday dates.',
        };
      }
      return {
        tone: 'warning',
        message: pending.join(' '),
      };
    },
  },
  {
    id: 'call-queue',
    title: 'Call Queue 301 (“Please Hold”)',
    intro:
      'Use Call Queue 301 only when a hold message is required after the first unanswered attempt. Configure the greeting and failover carefully.',
    tasks: [
      {
        id: 'queue-created',
        label: 'Create Call Queue 301 with “Please Hold” name',
        description:
          'Make sure all extensions are added to the Ring All strategy inside the queue.',
      },
      {
        id: 'queue-moh',
        label: 'Upload greeting and enable introductory playback',
        description:
          'Music on Hold should play the message: “Thank you for calling Mr. Handyman. All of our representatives are currently assisting other callers. Please remain on the line for the next available representative.”',
      },
      {
        id: 'queue-timeout',
        label: 'Set ring timeout to 30 seconds and configure failover',
        description:
          'After 30 seconds, redirect calls to the selected voicemail or answering service destination. Disable Call Queue 301 voicemail to avoid dual prompts.',
      },
    ],
    options: [
      {
        id: 'queue-failover',
        type: 'radio',
        legend: 'Queue 301 failover destination',
        choices: [
          { value: 'voicemail', label: 'Clarity voicemail inbox' },
          { value: 'answering-service', label: 'Answering service' },
          { value: 'user-300', label: 'Return to User 300 flow' },
        ],
      },
    ],
    suggestions: (state) => {
      if (!state.byId('queue-moh')) {
        return 'Confirm the introductory greeting has the approved Mr. Handyman script and meets audio quality standards.';
      }
      if (!state.optionSelected('queue-failover')) {
        return 'Select and document the queue failover destination to avoid circular routing.';
      }
      return 'Place a live test call that routes through the queue to experience the caller journey end-to-end.';
    },
    crossCheck: (state) => {
      const pending = [];
      if (!state.byId('queue-created')) pending.push('Queue 301 has not been created.');
      if (!state.byId('queue-moh')) pending.push('Introductory greeting upload is outstanding.');
      if (!state.byId('queue-timeout')) pending.push('Ring timeout or failover destination not confirmed.');
      if (!state.optionSelected('queue-failover'))
        pending.push('Failover destination not documented.');
      if (!pending.length) {
        return {
          tone: 'success',
          message: 'Call Queue 301 is production-ready.',
        };
      }
      return {
        tone: 'warning',
        message: pending.join(' '),
      };
    },
  },
  {
    id: 'user-300',
    title: 'User 300 Routing',
    intro:
      'Configure User 300 as the primary daytime answering point with appropriate failover and voicemail settings.',
    tasks: [
      {
        id: 'user-created',
        label: 'Create User 300 and attach Daytime Time Frame',
        description:
          'Ensure the Daytime Time Frame covers the correct schedule and rings all extensions in a simple hunt for 20 seconds.',
      },
      {
        id: 'user-unanswered',
        label: 'Configure unanswered path for daytime calls',
        description:
          'Select between voicemail, redirecting to cell phones, redirecting to Call Queue 301, or using the answering service.',
      },
      {
        id: 'user-failover',
        label: 'Add failover forwarding number',
        description:
          'Provide a backup number (answering service or mobile) in the failover field to protect against outages.',
      },
      {
        id: 'after-hours-rule',
        label: 'Create Default/AfterHours Answering Rule',
        description:
          'Confirm the customer’s preference and implement the matching after-hours behavior.',
      },
      {
        id: 'holiday-rule',
        label: 'Attach Holiday Time Frame routing',
        description:
          'Link the Holiday Time Frame and send callers to the customer’s preferred destination.',
      },
      {
        id: 'voicemail-disabled',
        label: 'Disable User 300 voicemail box',
        description:
          'Ensure the voicemail box is disabled so calls use the configured destination instead of storing in User 300.',
      },
    ],
    options: [
      {
        id: 'user-unanswered-option',
        type: 'radio',
        legend: 'Unanswered daytime handling',
        choices: [
          { value: 'voicemail', label: 'Voicemail on Clarity phone' },
          { value: 'cells-then-voicemail', label: 'Redirect to cell phone(s) then Clarity voicemail' },
          { value: 'queue-301', label: 'Redirect to Call Queue 301 ("Please Hold" message)' },
          { value: 'answering-service', label: 'Send to answering service' },
        ],
      },
    ],
    suggestions: (state) => {
      if (!state.byId('user-failover')) {
        return 'Add a failover destination in case the office loses connectivity or power.';
      }
      if (!state.optionSelected('user-unanswered-option')) {
        return 'Align on the preferred unanswered treatment and update the radio selection to track the decision.';
      }
      return 'Double-check the Daytime hunt order to confirm priority extensions ring first where needed.';
    },
    crossCheck: (state) => {
      const pending = [];
      if (!state.byId('user-created')) pending.push('User 300 not yet provisioned.');
      if (!state.byId('user-unanswered')) pending.push('Unanswered daytime path is incomplete.');
      if (!state.optionSelected('user-unanswered-option'))
        pending.push('Unanswered daytime option not documented.');
      if (!state.byId('user-failover')) pending.push('Failover forwarding number missing.');
      if (!state.byId('after-hours-rule')) pending.push('After-hours answering rule not configured.');
      if (!state.byId('holiday-rule')) pending.push('Holiday routing not linked.');
      if (!state.byId('voicemail-disabled')) pending.push('User 300 voicemail is still enabled.');
      if (!pending.length) {
        return {
          tone: 'success',
          message: 'User 300 routing is fully validated.',
        };
      }
      return {
        tone: 'warning',
        message: pending.join(' '),
      };
    },
  },
  {
    id: 'additional',
    title: 'Additional Required Configuration',
    intro:
      'Finalize the domain-wide settings, recordings, and integrations that support the franchise’s workflow.',
    tasks: [
      {
        id: 'extension-config',
        label: 'Configure each extension profile',
        description:
          'Add user names, enable voicemail-to-email, configure simul-ring to mobile devices, and turn on voicemail transcription.',
      },
      {
        id: 'call-recording',
        label: 'Enable call recording for all users/queues',
        description:
          'Either enable recordings individually or activate domain-wide recording if all call paths require retention.',
      },
      {
        id: 'default-moh',
        label: 'Upload “Mr. Handyman MOH” audio',
        description:
          'Set the uploaded file as the default Music on Hold for the account.',
      },
      {
        id: 'service-titan',
        label: 'Configure ServiceTitan integrations (if applicable)',
        description:
          'Follow the ServiceTitan wiki for inbound forwarding and outbound click-to-call settings. Note any API credentials or login requirements.',
      },
      {
        id: 'efax',
        label: 'Activate eFax service',
        description:
          'Confirm the owner’s preferred email address and finalize eFax routing.',
      },
    ],
    suggestions: (state) => {
      if (!state.byId('default-moh')) {
        return 'Upload the Mr. Handyman MOH file early; large audio files can take time to transcode.';
      }
      if (!state.byId('service-titan')) {
        return 'Coordinate with the ServiceTitan admin to verify API access before attempting configuration.';
      }
      return 'Consider documenting call recording retention timelines and who can retrieve the recordings.';
    },
    crossCheck: (state) => {
      const pending = [];
      if (!state.byId('extension-config')) pending.push('Extension profiles still need updates.');
      if (!state.byId('call-recording')) pending.push('Call recording not enabled everywhere.');
      if (!state.byId('default-moh')) pending.push('Default Music on Hold not uploaded.');
      if (!state.byId('service-titan')) pending.push('ServiceTitan integration unchecked.');
      if (!state.byId('efax')) pending.push('eFax activation not confirmed.');
      if (!pending.length) {
        return {
          tone: 'success',
          message: 'Additional configuration items are complete.',
        };
      }
      return {
        tone: 'warning',
        message: pending.join(' '),
      };
    },
  },
];

function encodeSharedState(data) {
  const encoder = new TextEncoder();
  const bytes = encoder.encode(JSON.stringify(data));
  let binary = '';
  bytes.forEach((byte) => {
    binary += String.fromCharCode(byte);
  });
  return btoa(binary);
}

function decodeSharedState(value) {
  const binary = atob(value);
  const bytes = Uint8Array.from(binary, (char) => char.charCodeAt(0));
  const decoder = new TextDecoder();
  const json = decoder.decode(bytes);
  return JSON.parse(json);
}

function createShareablePayload(state) {
  const payload = { tasks: {}, options: {} };
  if (!state) {
    return payload;
  }

  Object.entries(state.tasks || {}).forEach(([id, completed]) => {
    if (completed) {
      payload.tasks[id] = true;
    }
  });

  Object.entries(state.options || {}).forEach(([id, value]) => {
    if (Array.isArray(value)) {
      if (value.length) {
        payload.options[id] = value.map((item) => String(item));
      }
    } else if (value !== undefined && value !== null && value !== '') {
      payload.options[id] = String(value);
    }
  });

  if (!Object.keys(payload.tasks).length) {
    delete payload.tasks;
  }
  if (!Object.keys(payload.options).length) {
    delete payload.options;
  }

  return payload;
}

function applySharedStatePayload(targetState, payload) {
  if (!targetState || !payload || typeof payload !== 'object') {
    return;
  }

  targetState.tasks = {};
  targetState.options = {};
  if ('closing' in targetState) {
    delete targetState.closing;
  }

  if (payload.tasks && typeof payload.tasks === 'object') {
    Object.entries(payload.tasks).forEach(([id, completed]) => {
      if (completed) {
        targetState.tasks[id] = true;
      }
    });
  }

  if (payload.options && typeof payload.options === 'object') {
    Object.entries(payload.options).forEach(([id, value]) => {
      if (Array.isArray(value)) {
        if (value.length) {
          targetState.options[id] = value.map((item) => String(item));
        }
      } else if (value !== undefined && value !== null && value !== '') {
        targetState.options[id] = String(value);
      }
    });
  }

}

function loadSharedStateFromUrl() {
  try {
    const params = new URLSearchParams(window.location.search);
    if (!params.has(SHARE_PARAM)) {
      return { status: 'none' };
    }

    const encoded = params.get(SHARE_PARAM);
    if (!encoded) {
      return {
        status: 'error',
        message: 'Shared link was empty. Starting with a blank checklist.',
      };
    }

    const decoded = decodeSharedState(encoded);
    if (!decoded || typeof decoded !== 'object') {
      return {
        status: 'error',
        message: 'Shared link could not be read. Starting with a blank checklist.',
      };
    }

    return { status: 'success', state: decoded };
  } catch (error) {
    console.warn('Failed to read shared checklist state', error);
    return {
      status: 'error',
      message: 'Shared link could not be read. Starting with a blank checklist.',
    };
  }
}

function removeShareParamFromUrl() {
  try {
    const url = new URL(window.location.href);
    if (!url.searchParams.has(SHARE_PARAM)) {
      return;
    }
    url.searchParams.delete(SHARE_PARAM);
    window.history.replaceState({}, document.title, url.toString());
  } catch (error) {
    console.warn('Unable to clean share parameter from URL', error);
  }
}

const storage = {
  load() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      const parsed = raw ? JSON.parse(raw) : {};
      return {
        tasks: parsed.tasks || {},
        options: parsed.options || {},
      };
    } catch (error) {
      console.warn('Unable to read saved state:', error);
      return { tasks: {}, options: {} };
    }
  },
  save(state) {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    } catch (error) {
      console.warn('Unable to persist state:', error);
    }
  },
  clear() {
    try {
      localStorage.removeItem(STORAGE_KEY);
    } catch (error) {
      console.warn('Unable to clear saved state:', error);
    }
  },
};

const savedState = storage.load();
if (!savedState.tasks) savedState.tasks = {};
if (!savedState.options) savedState.options = {};

let shareStatusElement = null;
let pendingShareImportMessage = '';
let pendingShareImportTone = 'info';

const sharedStateLoadResult = loadSharedStateFromUrl();
if (sharedStateLoadResult.status === 'success') {
  applySharedStatePayload(savedState, sharedStateLoadResult.state);
  storage.save(savedState);
  pendingShareImportMessage =
    'Loaded checklist progress from a shared link. Updates will now save to this device.';
  pendingShareImportTone = 'success';
  removeShareParamFromUrl();
} else if (sharedStateLoadResult.status === 'error') {
  pendingShareImportMessage = sharedStateLoadResult.message;
  pendingShareImportTone = 'warning';
  removeShareParamFromUrl();
}

let previewOverlay = null;
let previewDialog = null;
let previewBody = null;
let previewHideTimer = null;
let lastFocusedElement = null;
let previewFocusableElements = [];
let previewFirstFocusable = null;
let previewLastFocusable = null;
let livePreviewContainer = null;
let livePreviewBody = null;
let latestPreviewSnapshot = null;
let demoOverlay = null;
let demoDialog = null;
let demoStepIndicator = null;
let demoStepTitle = null;
let demoStepText = null;
let demoPrevButton = null;
let demoNextButton = null;
let demoCloseButtons = [];
let demoCurrentStep = 0;
let demoActive = false;
let demoStateBackup = null;
let demoHighlightedElement = null;
let demoHideTimer = null;
let demoReturnFocus = null;

const demoSamplePayload = {
  tasks: {
    'daytime-frame': true,
    'holiday-frame': true,
    'queue-created': true,
    'queue-moh': true,
    'queue-timeout': true,
    'user-created': true,
    'user-unanswered': true,
    'user-failover': true,
    'after-hours-rule': true,
    'holiday-rule': true,
    'voicemail-disabled': true,
    'extension-config': true,
    'call-recording': true,
    'default-moh': true,
  },
  options: {
    'after-hours-destination': 'answering-service',
    'queue-failover': 'answering-service',
    'user-unanswered-option': 'queue-301',
  },
};

const demoSteps = [
  {
    id: 'progress',
    target: '.progress',
    title: 'Track overall progress',
    description:
      'The progress bar updates automatically as you check off items, showing stakeholders how much of the launch plan is complete.',
  },
  {
    id: 'timeframes',
    target: '.section[data-section-id="time-frames"]',
    title: 'Review AI suggestions and cross-checks',
    description:
      'Each section provides AI suggestions and cross-check callouts. Use them to confirm holiday routing and other time frame details before go-live.',
  },
  {
    id: 'share',
    target: '#btn-share',
    title: 'Generate a shareable link',
    description:
      'Share Progress Link packages the current state into a URL for teammates or leadership. Copy it directly or open the Web Share dialog.',
  },
  {
    id: 'preview',
    target: '#live-preview',
    title: 'Show the environment preview',
    description:
      'The live environment preview summarizes completion counts, cross-check results, and guidance so you can present readiness in real time.',
  },
];

function clearShareStatus() {
  if (!shareStatusElement) return;
  shareStatusElement.innerHTML = '';
  shareStatusElement.removeAttribute('data-tone');
  shareStatusElement.hidden = true;
}

function setShareStatus(message, tone = 'info', link) {
  if (!shareStatusElement) return;

  shareStatusElement.innerHTML = '';
  shareStatusElement.dataset.tone = tone;
  shareStatusElement.hidden = false;

  const messageEl = document.createElement('strong');
  messageEl.className = 'share-status__message';
  messageEl.textContent = message;
  shareStatusElement.appendChild(messageEl);

  if (link) {
    const linkBlock = document.createElement('div');
    linkBlock.className = 'share-status__link-block';

    const hint = document.createElement('span');
    hint.textContent = 'Share this link:';
    linkBlock.appendChild(hint);

    const anchor = document.createElement('a');
    anchor.className = 'share-status__link';
    anchor.href = link;
    anchor.textContent = link;
    anchor.target = '_blank';
    anchor.rel = 'noopener noreferrer';
    linkBlock.appendChild(anchor);

    shareStatusElement.appendChild(linkBlock);
  }
}

function buildShareUrl() {
  const payload = createShareablePayload(savedState);
  const encoded = encodeSharedState(payload);
  const url = new URL(window.location.href);
  url.searchParams.set(SHARE_PARAM, encoded);
  return url.toString();
}

async function shareCurrentProgress() {
  const shareUrl = buildShareUrl();

  if (navigator.share) {
    const shareData = {
      title: 'Mr. Handyman Best Practices Checklist',
      text: 'Review the Mr. Handyman verification checklist progress I captured.',
      url: shareUrl,
    };
    try {
      if (!navigator.canShare || navigator.canShare(shareData)) {
        await navigator.share(shareData);
        setShareStatus(
          'Share dialog opened. If you still need the URL, copy it from the link below.',
          'success',
          shareUrl
        );
        return;
      }
    } catch (error) {
      if (error && error.name === 'AbortError') {
        setShareStatus(
          'Share canceled. Copy the link below to send your progress manually.',
          'info',
          shareUrl
        );
        return;
      }
      console.warn('Web Share API failed, falling back to clipboard.', error);
    }
  }

  if (navigator.clipboard && navigator.clipboard.writeText) {
    try {
      await navigator.clipboard.writeText(shareUrl);
      setShareStatus('Shareable link copied to your clipboard.', 'success', shareUrl);
      return;
    } catch (error) {
      console.warn('Clipboard write failed', error);
    }
  }

  setShareStatus('Copy this link to share your progress.', 'warning', shareUrl);
}

function cloneDemoState(state) {
  try {
    return JSON.parse(
      JSON.stringify(
        state || {
          tasks: {},
          options: {},
        }
      )
    );
  } catch (error) {
    console.warn('Unable to clone checklist state for demo backup.', error);
    return { tasks: {}, options: {} };
  }
}

function applyDemoPayload(payload) {
  applySharedStatePayload(savedState, payload);
  storage.save(savedState);
  renderChecklist();
  updateProgress();
}

function restoreStateFromBackup(backup) {
  const source = backup || { tasks: {}, options: {} };

  savedState.tasks = {};
  if (source.tasks && typeof source.tasks === 'object') {
    Object.entries(source.tasks).forEach(([id, value]) => {
      if (value) {
        savedState.tasks[id] = true;
      }
    });
  }

  savedState.options = {};
  if (source.options && typeof source.options === 'object') {
    Object.entries(source.options).forEach(([id, value]) => {
      if (Array.isArray(value)) {
        savedState.options[id] = [...value];
      } else if (value !== undefined && value !== null) {
        savedState.options[id] = value;
      }
    });
  }
  if ('closing' in savedState) {
    delete savedState.closing;
  }

  storage.save(savedState);
  renderChecklist();
  updateProgress();
}

function clearDemoHighlight() {
  if (demoHighlightedElement) {
    demoHighlightedElement.classList.remove('demo-highlight');
    demoHighlightedElement = null;
  }
}

function highlightDemoTarget(selector) {
  clearDemoHighlight();
  if (!selector) return;

  const element = document.querySelector(selector);
  if (!element) {
    return;
  }

  element.classList.add('demo-highlight');
  if (typeof element.scrollIntoView === 'function') {
    element.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
  }
  demoHighlightedElement = element;
}

function updateDemoControls() {
  if (!demoActive) {
    return;
  }

  const totalSteps = demoSteps.length;
  const currentIndex = Math.min(Math.max(demoCurrentStep, 0), totalSteps - 1);
  const step = demoSteps[currentIndex];

  if (demoStepIndicator) {
    demoStepIndicator.textContent = `Step ${currentIndex + 1} of ${totalSteps}`;
  }
  if (demoStepTitle) {
    demoStepTitle.textContent = step ? step.title : '';
  }
  if (demoStepText) {
    demoStepText.textContent = step ? step.description : '';
  }

  if (demoPrevButton) {
    demoPrevButton.disabled = currentIndex === 0;
  }

  if (demoNextButton) {
    demoNextButton.textContent = currentIndex === totalSteps - 1 ? 'Finish' : 'Next';
  }

  if (step && step.target) {
    highlightDemoTarget(step.target);
  } else {
    clearDemoHighlight();
  }
}

function goToDemoStep(index) {
  if (!demoActive) {
    return;
  }

  demoCurrentStep = Math.min(Math.max(index, 0), demoSteps.length - 1);
  updateDemoControls();
}

function openDemoOverlay() {
  if (!demoOverlay) return;

  if (demoHideTimer) {
    clearTimeout(demoHideTimer);
    demoHideTimer = null;
  }

  demoOverlay.hidden = false;
  requestAnimationFrame(() => {
    demoOverlay.setAttribute('aria-hidden', 'false');
  });
  document.body.classList.add('no-scroll');

  const focusTarget = demoDialog || demoOverlay;
  if (focusTarget && typeof focusTarget.focus === 'function') {
    focusTarget.focus();
  }

  document.addEventListener('keydown', handleDemoKeydown);
}

function closeDemoOverlay() {
  if (!demoOverlay) return;

  demoOverlay.setAttribute('aria-hidden', 'true');
  if (demoHideTimer) {
    clearTimeout(demoHideTimer);
  }
  demoHideTimer = setTimeout(() => {
    demoOverlay.hidden = true;
    demoHideTimer = null;
  }, 200);

  document.body.classList.remove('no-scroll');
  document.removeEventListener('keydown', handleDemoKeydown);
}

function handleDemoKeydown(event) {
  if (!demoActive) {
    return;
  }

  if (event.key === 'Escape') {
    event.preventDefault();
    endDemoPresentation();
    return;
  }

  if (event.key === 'ArrowRight') {
    event.preventDefault();
    if (demoCurrentStep < demoSteps.length - 1) {
      goToDemoStep(demoCurrentStep + 1);
    } else {
      endDemoPresentation();
    }
  } else if (event.key === 'ArrowLeft') {
    event.preventDefault();
    if (demoCurrentStep > 0) {
      goToDemoStep(demoCurrentStep - 1);
    }
  }
}

function startDemoPresentation() {
  if (demoActive) {
    goToDemoStep(0);
    return;
  }

  demoActive = true;
  demoReturnFocus = document.activeElement;
  demoStateBackup = cloneDemoState(savedState);
  applyDemoPayload(demoSamplePayload);

  if (shareStatusElement) {
    setShareStatus(
      'Mr.Handyman Best Practies Checklist loaded example data. Advance through the walkthrough or end the demo to restore your saved work.',
      'info'
    );
  }

  openDemoOverlay();
  goToDemoStep(0);
}

function endDemoPresentation() {
  if (!demoActive) {
    return;
  }

  demoActive = false;
  closeDemoOverlay();
  clearDemoHighlight();
  restoreStateFromBackup(demoStateBackup);
  demoStateBackup = null;

  if (shareStatusElement) {
    setShareStatus('Mr.Handyman Best Practies Checklist closed. Your saved progress has been restored.', 'success');
  }

  const focusTarget = demoReturnFocus && typeof demoReturnFocus.focus === 'function' ? demoReturnFocus : null;
  demoReturnFocus = null;
  if (focusTarget) {
    focusTarget.focus();
  }
}

function isElementVisible(element) {
  if (!element) return false;
  if (element.hasAttribute('hidden') || element.closest('[hidden]')) {
    return false;
  }
  const style = window.getComputedStyle(element);
  return style.display !== 'none' && style.visibility !== 'hidden';
}

function preparePreviewFocusTrap() {
  if (!previewOverlay) return;
  const focusableSelector =
    'a[href], area[href], button:not([disabled]), input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])';
  previewFocusableElements = Array.from(
    previewOverlay.querySelectorAll(focusableSelector)
  ).filter((element) => isElementVisible(element));

  previewFirstFocusable =
    previewFocusableElements[0] || previewDialog || previewOverlay;
  previewLastFocusable =
    previewFocusableElements[previewFocusableElements.length - 1] ||
    previewFirstFocusable;
}

function createStateHelpers(section) {
  const taskStatus = (section.tasks || []).map((task) => ({
    ...task,
    completed: Boolean(savedState.tasks[task.id]),
  }));

  return {
    tasks: taskStatus,
    byId(id) {
      return Boolean(savedState.tasks[id]);
    },
    optionSelected(groupId) {
      const selection = savedState.options[groupId];
      if (Array.isArray(selection)) {
        return selection.length > 0;
      }
      return Boolean(selection);
    },
  };
}

function renderChecklist() {
  const container = document.getElementById('checklist');
  const sectionTemplate = document.getElementById('section-template');
  const taskTemplate = document.getElementById('task-template');
  const optionTemplate = document.getElementById('option-template');
  const radioTemplate = document.getElementById('radio-template');
  const checkboxTemplate = document.getElementById('checkbox-template');

  if (!container) {
    return;
  }

  container.innerHTML = '';

  checklistData.forEach((section) => {
    const sectionFragment = sectionTemplate.content.cloneNode(true);
    const sectionEl = sectionFragment.querySelector('.section');
    sectionEl.dataset.sectionId = section.id;
    sectionFragment.querySelector('.section__title').textContent = section.title;
    sectionFragment.querySelector('.section__intro').textContent = section.intro;

    const contentEl = sectionFragment.querySelector('.section__content');

    (section.tasks || []).forEach((task) => {
      const taskFragment = taskTemplate.content.cloneNode(true);
      const taskEl = taskFragment.querySelector('.task');
      taskEl.dataset.taskId = task.id;

      const checkbox = taskFragment.querySelector('input[type="checkbox"]');
      checkbox.checked = Boolean(savedState.tasks[task.id]);
      taskEl.classList.toggle('completed', checkbox.checked);
      checkbox.addEventListener('change', () => {
        savedState.tasks[task.id] = checkbox.checked;
        taskEl.classList.toggle('completed', checkbox.checked);
        storage.save(savedState);
        updateProgress();
      });

      taskFragment.querySelector('.task__text').textContent = task.label;
      const descriptionEl = taskFragment.querySelector('.task__description');
      if (task.descriptionHtml) {
        descriptionEl.innerHTML = task.descriptionHtml;
      } else {
        descriptionEl.textContent = task.description || 'Add notes as needed.';
      }

      contentEl.appendChild(taskFragment);
    });

    (section.options || []).forEach((group) => {
      const optionFragment = optionTemplate.content.cloneNode(true);
      const fieldset = optionFragment.querySelector('fieldset');
      fieldset.dataset.groupId = group.id;
      fieldset.querySelector('legend').textContent = group.legend;
      if (group.description) {
        const desc = document.createElement('p');
        desc.className = 'options__description';
        desc.textContent = group.description;
        fieldset.appendChild(desc);
      }

      const storedValue = savedState.options[group.id];

      group.choices.forEach((choice) => {
        const template = group.type === 'checkbox' ? checkboxTemplate : radioTemplate;
        const optionNode = template.content.cloneNode(true);
        const input = optionNode.querySelector('input');
        const optionLabel = optionNode.querySelector('.option__label');

        if (group.type === 'radio') {
          input.type = 'radio';
          input.name = group.id;
          input.value = choice.value;
          input.checked = storedValue === choice.value;
        } else {
          input.type = 'checkbox';
          input.name = `${group.id}-${choice.value}`;
          input.value = choice.value;
          input.checked = Array.isArray(storedValue)
            ? storedValue.includes(choice.value)
            : false;
        }

        optionLabel.textContent = choice.label;
        if (choice.note) {
          const note = document.createElement('span');
          note.className = 'option__note';
          const labelSpan = document.createElement('span');
          labelSpan.textContent = choice.note;
          const lineSpan = document.createElement('span');
          lineSpan.className = 'fill-line';
          lineSpan.setAttribute('aria-hidden', 'true');
          note.appendChild(labelSpan);
          note.appendChild(lineSpan);
          optionLabel.appendChild(note);
        }

        input.addEventListener('change', () => {
          if (group.type === 'radio') {
            savedState.options[group.id] = input.value;
          } else {
            const current = Array.isArray(savedState.options[group.id])
              ? [...savedState.options[group.id]]
              : [];
            if (input.checked) {
              current.push(choice.value);
            } else {
              const index = current.indexOf(choice.value);
              if (index >= 0) current.splice(index, 1);
            }
            savedState.options[group.id] = current;
          }
          storage.save(savedState);
          updateProgress();
        });

        fieldset.appendChild(optionNode);
      });

      contentEl.appendChild(optionFragment);
    });

    container.appendChild(sectionFragment);
  });

  if (demoActive) {
    requestAnimationFrame(() => {
      goToDemoStep(demoCurrentStep);
    });
  }

  refreshSectionInsights();
}

function refreshSectionInsights() {
  checklistData.forEach((section) => {
    const sectionEl = document.querySelector(
      `.section[data-section-id="${section.id}"]`
    );
    if (!sectionEl) return;

    const insightsEl = sectionEl.querySelector('.section__insights');
    if (!insightsEl) return;

    const helpers = createStateHelpers(section);
    const suggestion = section.suggestions ? section.suggestions(helpers) : '';
    const message = suggestion ? suggestion.trim() : '';

    insightsEl.innerHTML = '';
    if (message) {
      const titleEl = document.createElement('strong');
      titleEl.textContent = 'AI Suggestion';
      insightsEl.appendChild(titleEl);

      const messageEl = document.createElement('span');
      messageEl.className = 'section__insights-text';
      messageEl.textContent = message;
      insightsEl.appendChild(messageEl);

      insightsEl.classList.add('is-visible');
      insightsEl.dataset.tone = 'info';
    } else {
      insightsEl.classList.remove('is-visible');
      insightsEl.removeAttribute('data-tone');
    }
  });
}

function updateProgress() {
  const progressText = document.querySelector('.progress__summary');
  const progressBar = document.querySelector('.progress-bar');
  const progressBarFill = document.querySelector('.progress-bar__fill');
  const snapshot = getPreviewSnapshot();
  latestPreviewSnapshot = snapshot;

  if (progressBarFill) {
    progressBarFill.style.width = `${snapshot.percent}%`;
  }
  if (progressBar) {
    progressBar.setAttribute('aria-valuenow', snapshot.percent);
  }
  if (progressText) {
    progressText.textContent = `${snapshot.completed} of ${snapshot.total} checklist items captured (${snapshot.percent}%).`;
  }

  renderLivePreview(snapshot);
  refreshPreviewIfOpen(snapshot);
  refreshSectionInsights();
}

function bindControls() {
  shareStatusElement = document.getElementById('share-status');
  if (shareStatusElement) {
    clearShareStatus();
    if (pendingShareImportMessage) {
      setShareStatus(pendingShareImportMessage, pendingShareImportTone);
      pendingShareImportMessage = '';
      pendingShareImportTone = 'info';
    }
  }

  const clearButton = document.getElementById('btn-clear');
  clearButton.addEventListener('click', () => {
    if (confirm('This will remove all saved progress. Continue?')) {
      storage.clear();
      Object.keys(savedState.tasks).forEach((key) => delete savedState.tasks[key]);
      Object.keys(savedState.options).forEach((key) => delete savedState.options[key]);
      if ('closing' in savedState) delete savedState.closing;
      document.querySelectorAll('input[type="checkbox"]').forEach((input) => {
        input.checked = false;
      });
      document
        .querySelectorAll('input[type="radio"]:checked')
        .forEach((input) => (input.checked = false));
      updateProgress();
      document
        .querySelectorAll('.section__insights')
        .forEach((el) => el.classList.remove('is-visible'));
      clearShareStatus();
    }
  });

  const shareButton = document.getElementById('btn-share');
  if (shareButton) {
    shareButton.addEventListener('click', async () => {
      clearShareStatus();
      shareButton.disabled = true;
      try {
        await shareCurrentProgress();
      } finally {
        shareButton.disabled = false;
      }
    });
  }

  const previewButton = document.getElementById('btn-preview');
  if (previewButton) {
    previewButton.addEventListener('click', () => {
      lastFocusedElement = document.activeElement;
      openPreview();
    });
  }

  const demoButton = document.getElementById('btn-demo');
  if (demoButton) {
    demoButton.addEventListener('click', startDemoPresentation);
  }

  document.querySelectorAll('[data-preview-close]').forEach((element) => {
    element.addEventListener('click', closePreview);
  });
}

function init() {
  renderChecklist();
  bindControls();
  livePreviewContainer = document.getElementById('live-preview');
  livePreviewBody = livePreviewContainer
    ? livePreviewContainer.querySelector('.live-preview__body')
    : null;
  previewOverlay = document.getElementById('preview-overlay');
  previewDialog = previewOverlay ? previewOverlay.querySelector('.preview__dialog') : null;
  previewBody = previewDialog ? previewDialog.querySelector('.preview__body') : null;
  if (previewOverlay) {
    previewOverlay.addEventListener('click', (event) => {
      if (event.target === previewOverlay) {
        closePreview();
      }
    });
  }

  demoOverlay = document.getElementById('demo-overlay');
  if (demoOverlay) {
    demoDialog = demoOverlay.querySelector('.demo__dialog');
    demoStepIndicator = demoOverlay.querySelector('.demo__step-indicator');
    demoStepTitle = demoOverlay.querySelector('.demo__step-title');
    demoStepText = demoOverlay.querySelector('.demo__step-text');
    demoPrevButton = demoOverlay.querySelector('[data-demo-prev]');
    demoNextButton = demoOverlay.querySelector('[data-demo-next]');
    demoCloseButtons = Array.from(demoOverlay.querySelectorAll('[data-demo-close]'));

    if (demoPrevButton) {
      demoPrevButton.addEventListener('click', () => {
        goToDemoStep(demoCurrentStep - 1);
      });
    }

    if (demoNextButton) {
      demoNextButton.addEventListener('click', () => {
        if (demoCurrentStep >= demoSteps.length - 1) {
          endDemoPresentation();
        } else {
          goToDemoStep(demoCurrentStep + 1);
        }
      });
    }

    demoCloseButtons.forEach((element) => {
      element.addEventListener('click', endDemoPresentation);
    });
  }

  updateProgress();
}

document.addEventListener('DOMContentLoaded', init);

function computeSectionPreview(section) {
  const helpers = createStateHelpers(section);
  const items = [];

  (helpers.tasks || []).forEach((task) => {
    items.push({
      label: task.label,
      state: task.completed ? 'complete' : 'pending',
      text: task.completed ? 'Complete' : 'Needs attention',
    });
  });

  (section.options || []).forEach((group) => {
    if (group.type === 'radio') {
      const value = savedState.options[group.id];
      const choice = (group.choices || []).find((option) => option.value === value);
      items.push({
        label: group.legend,
        state: choice ? 'complete' : 'pending',
        text: choice ? choice.label : 'Not selected',
      });
    } else {
      const value = savedState.options[group.id];
      const selections = Array.isArray(value) ? value : [];
      const labels = (group.choices || [])
        .filter((option) => selections.includes(option.value))
        .map((option) => option.label);
      items.push({
        label: group.legend,
        state: labels.length ? 'complete' : 'pending',
        text: labels.length ? labels.join(', ') : 'No selections',
      });
    }
  });

  const crossCheck = section.crossCheck ? section.crossCheck(helpers) : null;
  const suggestion = section.suggestions ? section.suggestions(helpers) : '';

  return {
    title: section.title,
    completed: items.filter((item) => item.state === 'complete').length,
    total: items.length,
    items,
    crossCheck,
    suggestion,
  };
}

function getPreviewSnapshot() {
  const sections = checklistData.map((section) => computeSectionPreview(section));
  const totals = sections.reduce(
    (acc, section) => {
      acc.completed += section.completed;
      acc.total += section.total;
      return acc;
    },
    { completed: 0, total: 0 }
  );

  const percent = totals.total ? Math.round((totals.completed / totals.total) * 100) : 0;

  return {
    sections,
    completed: totals.completed,
    total: totals.total,
    percent,
  };
}

function renderLivePreview(snapshot = latestPreviewSnapshot || getPreviewSnapshot()) {
  if (!livePreviewBody) return;

  const data = snapshot || getPreviewSnapshot();
  const fragment = document.createDocumentFragment();

  const summary = document.createElement('div');
  summary.className = 'live-preview__summary';

  const summaryHeading = document.createElement('strong');
  summaryHeading.textContent = 'Snapshot overview';
  summary.appendChild(summaryHeading);

  const summaryDetail = document.createElement('span');
  summaryDetail.textContent = data.total
    ? `${data.completed} of ${data.total} environment items captured (${data.percent}%).`
    : 'No environment items have been captured yet.';
  summary.appendChild(summaryDetail);

  fragment.appendChild(summary);

  data.sections.forEach((section) => {
    const sectionEl = document.createElement('section');
    sectionEl.className = 'live-preview__section';

    const headerEl = document.createElement('div');
    headerEl.className = 'live-preview__section-header';

    const titleEl = document.createElement('h3');
    titleEl.className = 'live-preview__section-title';
    titleEl.textContent = section.title;
    headerEl.appendChild(titleEl);

    const progressEl = document.createElement('span');
    progressEl.className = 'live-preview__section-progress';
    progressEl.textContent = section.total ? `${section.completed}/${section.total}` : 'No items';
    headerEl.appendChild(progressEl);

    sectionEl.appendChild(headerEl);

    if (section.crossCheck && section.crossCheck.message) {
      const statusEl = document.createElement('p');
      statusEl.className = 'live-preview__section-status';
      statusEl.dataset.tone = section.crossCheck.tone || 'info';
      statusEl.textContent = section.crossCheck.message;
      sectionEl.appendChild(statusEl);
    }

    if (section.suggestion) {
      const suggestionEl = document.createElement('p');
      suggestionEl.className = 'live-preview__section-suggestion';
      suggestionEl.textContent = section.suggestion;
      sectionEl.appendChild(suggestionEl);
    }

    if (section.items.length) {
      const itemsList = document.createElement('ul');
      itemsList.className = 'live-preview__items';

      section.items.forEach((item) => {
        const itemRow = document.createElement('li');
        itemRow.className = 'live-preview__item';

        const label = document.createElement('span');
        label.className = 'live-preview__item-label';
        label.textContent = item.label;
        itemRow.appendChild(label);

        const status = document.createElement('span');
        status.className = 'live-preview__item-status';
        status.dataset.state = item.state;
        status.textContent = item.text;
        itemRow.appendChild(status);

        itemsList.appendChild(itemRow);
      });

      sectionEl.appendChild(itemsList);
    }

    fragment.appendChild(sectionEl);
  });

  livePreviewBody.innerHTML = '';
  livePreviewBody.appendChild(fragment);
}

function renderPreviewContent(snapshot = latestPreviewSnapshot || getPreviewSnapshot()) {
  if (!previewBody) return;

  const data = snapshot || getPreviewSnapshot();
  const fragment = document.createDocumentFragment();

  const summary = document.createElement('div');
  summary.className = 'preview__summary';
  summary.textContent = data.total
    ? `${data.completed} of ${data.total} environment items are configured.`
    : 'No configuration items defined.';
  fragment.appendChild(summary);

  data.sections.forEach((section) => {
    const sectionEl = document.createElement('section');
    sectionEl.className = 'preview__section';

    const headerEl = document.createElement('div');
    headerEl.className = 'preview__section-header';

    const titleEl = document.createElement('h3');
    titleEl.className = 'preview__section-title';
    titleEl.textContent = section.title;
    headerEl.appendChild(titleEl);

    const progressEl = document.createElement('span');
    progressEl.className = 'preview__section-progress';
    progressEl.textContent = section.total
      ? `${section.completed}/${section.total} complete`
      : 'No items';
    headerEl.appendChild(progressEl);

    sectionEl.appendChild(headerEl);

    if (section.crossCheck && section.crossCheck.message) {
      const statusEl = document.createElement('p');
      statusEl.className = 'preview__section-status';
      statusEl.dataset.tone = section.crossCheck.tone || 'info';
      statusEl.textContent = section.crossCheck.message;
      sectionEl.appendChild(statusEl);
    }

    if (section.suggestion) {
      const suggestionEl = document.createElement('p');
      suggestionEl.className = 'preview__section-suggestion';
      suggestionEl.textContent = section.suggestion;
      sectionEl.appendChild(suggestionEl);
    }

    if (section.items.length) {
      const itemsList = document.createElement('div');
      itemsList.className = 'preview__items';

      section.items.forEach((item) => {
        const itemRow = document.createElement('div');
        itemRow.className = 'preview__item';

        const label = document.createElement('span');
        label.className = 'preview__item-label';
        label.textContent = item.label;
        itemRow.appendChild(label);

        const status = document.createElement('span');
        status.className = 'preview__item-status';
        status.dataset.state = item.state;
        status.textContent = item.text;
        itemRow.appendChild(status);

        itemsList.appendChild(itemRow);
      });

      sectionEl.appendChild(itemsList);
    }

    fragment.appendChild(sectionEl);
  });

  previewBody.innerHTML = '';
  previewBody.appendChild(fragment);
  preparePreviewFocusTrap();
}

function refreshPreviewIfOpen(snapshot = latestPreviewSnapshot || getPreviewSnapshot()) {
  if (previewOverlay && previewOverlay.getAttribute('aria-hidden') === 'false') {
    renderPreviewContent(snapshot);
  }
}

function openPreview() {
  if (!previewOverlay) return;

  if (previewHideTimer) {
    clearTimeout(previewHideTimer);
    previewHideTimer = null;
  }

  renderPreviewContent(latestPreviewSnapshot || getPreviewSnapshot());
  previewOverlay.hidden = false;
  requestAnimationFrame(() => {
    previewOverlay.setAttribute('aria-hidden', 'false');
  });
  document.body.classList.add('no-scroll');

  const closeButton = previewOverlay.querySelector('.preview__close');
  const focusTarget =
    (previewFirstFocusable && previewOverlay.contains(previewFirstFocusable)
      ? previewFirstFocusable
      : null) ||
    closeButton ||
    previewDialog;
  if (focusTarget && typeof focusTarget.focus === 'function') {
    focusTarget.focus();
  }

  document.addEventListener('keydown', handlePreviewKeydown);
}

function closePreview() {
  if (!previewOverlay) return;

  previewOverlay.setAttribute('aria-hidden', 'true');
  if (previewHideTimer) {
    clearTimeout(previewHideTimer);
  }
  previewHideTimer = setTimeout(() => {
    previewOverlay.hidden = true;
    previewHideTimer = null;
  }, 200);

  document.body.classList.remove('no-scroll');
  document.removeEventListener('keydown', handlePreviewKeydown);
  previewFocusableElements = [];
  previewFirstFocusable = null;
  previewLastFocusable = null;

  if (lastFocusedElement && typeof lastFocusedElement.focus === 'function') {
    lastFocusedElement.focus();
  }
}

function handlePreviewKeydown(event) {
  if (event.key === 'Escape') {
    event.preventDefault();
    closePreview();
    return;
  }

  if (event.key === 'Tab' && previewOverlay && previewOverlay.getAttribute('aria-hidden') === 'false') {
    const activeElement = document.activeElement;
    const first = previewFirstFocusable || previewDialog;
    const last = previewLastFocusable || first;

    if (!previewFocusableElements.length) {
      event.preventDefault();
      if (first && typeof first.focus === 'function') {
        first.focus();
      }
      return;
    }

    if (!previewOverlay.contains(activeElement)) {
      event.preventDefault();
      if (first && typeof first.focus === 'function') {
        first.focus();
      }
      return;
    }

    if (event.shiftKey) {
      if (activeElement === first) {
        event.preventDefault();
        if (last && typeof last.focus === 'function') {
          last.focus();
        }
      }
    } else if (activeElement === last) {
      event.preventDefault();
      if (first && typeof first.focus === 'function') {
        first.focus();
      }
    }
  }
}

</script>
  </body>
</html>
